/*!
 * -------------------------------------------
 * Copyright (c) 2019, Horizon Robotics, Inc.
 * All rights reserved.
 * \File     xplugin.h
 * \Author   Yingmin Li
 * \Mail     yingmin.li@horizon.ai
 * \contributor  songshan.gong
 * \Mail     songshan.gong@horizon.ai
 * \Version  1.0.0.0
 * \Date     2019-07-29
 * \Brief    implement of xplugin.h
 * \DO NOT MODIFY THIS COMMENT, \
 * \WHICH IS AUTO GENERATED BY EDITOR
 * -------------------------------------------
 */

#ifndef INCLUDE_XPLUGINFLOW_PLUGIN_XPLUGINASYNC_H_
#define INCLUDE_XPLUGINFLOW_PLUGIN_XPLUGINASYNC_H_
#include <map>
#include <string>
#include "xpluginflow/plugin/xplugin.h"
#include "xpluginflow/message/pluginflow/flowmsg.h"
#include "xpluginflow/threads/threadpool.h"
namespace horizon {
namespace vision {
namespace xpluginflow {

/*
 * \Desc Plugin实现
 *       消息处理包含上半部分和下半部分：
 *       1）上半部分接收总线消息并推送到本地队列；
 *       2）本地执行引擎调度下半部分完成消息的分发和处理
*/
class XPluginAsync : public XPlugin {
 public:
  XPluginAsync();
  explicit XPluginAsync(int thread_num);
  ~XPluginAsync() override = default;
  // 注册监听消息类型到总线+plugin的初始化
  int Init() override;
  // 消息处理上半部分，将消息推送该plugin的消息队列 + 流量控制
  void OnMsg(XPluginFlowMessagePtr msg);
  // 启动Plugin
  virtual int Start() {
    return 0;
  }
  // 停止Plugin
  virtual int Stop() {
    return 0;
  }

 protected:
  using XPluginFlowMessageFunc = std::function<int(XPluginFlowMessagePtr)>;
  // 重载注册监听消息类型接口，注册时包含异步回调函数
  // 该函数中需要调用RegisterMsg(XpluginMessageType type)完成总线注册
  // Note: 自定义的plugin需要在Init函数中，
  //       调用XPluginAsync::Init之前调用该接口完成监听消息注册。
  void RegisterMsg(const std::string& type, XPluginFlowMessageFunc callback);

 private:
  // 消息处理下半部分，分发消息并调用对应的callback函数
  void OnMsgDown(XPluginFlowMessagePtr msg);

  hobot::CThreadPool msg_handle_;
  std::map<std::string, XPluginFlowMessageFunc> msg_map_;
};

}  // namespace xpluginflow
}  // namespace vision
}  // namespace horizon
#endif  // INCLUDE_XPLUGINFLOW_PLUGIN_XPLUGINASYNC_H_
