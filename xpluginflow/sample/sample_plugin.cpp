/*!
 * -------------------------------------------
 * Copyright (c) 2019, Horizon Robotics, Inc.
 * All rights reserved.
 * \File     sample_plugin.cpp
 * \Author Songshan Gong
 * \Mail     songshan.gong@horizon.ai
 * \Version  1.0.0.0
 * \Date     2019-07-30
 * \Brief    Sample custom plugin
 * \DO NOT MODIFY THIS COMMENT, \
 * \WHICH IS AUTO GENERATED BY EDITOR
 * -------------------------------------------
 */

#include <unistd.h>
#include <signal.h>
#include <sstream>
#include <iostream>
#include "xpluginflow/plugin/xpluginasync.h"
#include "xpluginflow/message/pluginflow/flowmsg.h"
#include "xpluginflow/message/pluginflow/msg_registry.h"

#include "hobotlog/hobotlog.hpp"

/*
 * 框架包含三部分：总线、消息、插件。
 * 总线是系统框架，用户不用care;
 * 插件的定义：
 * 1.需要继承XPluginAsync，通常需要override的函数包括:
 *   Init()、Start()、Stop()、Desc();
 * 2.插件可能会生产消息或者向总线注册监听某类消息：
 *   如果生产消息需要调用PushMsg()将消息发送到总线分发;
 *   如果监听消息，需要实现消息处理函数，并在Init函数中
 *   注册需要监听的消息类型，并绑定对应的消息处理函数，
 *   同时在Init函数返回前调用父plugin的Init方法，
 *   通常是XPluginAsync::Init()。
 * 消息的声明与定义：
 * 1.使用宏XPLUGIN_REGISTER_MSG_TYPE,自定义消息类型，每个消息名字唯一；
 * 2.定义新的Message需要继承XPluginFlowMessage;
 * 3.需要监听消息的插件需要：
 *   a.实现消息处理函数；
 *   b.覆盖Init函数，在其中完成监听消息注册，并绑定对应的消息处理函数，
 *     及其他初始化工作，同时在函数返回前需要调用父plugin的Init方法，
 *     通常是XPluginAsync::Init()。
*/

using horizon::vision::xpluginflow::XPluginAsync;
using horizon::vision::xpluginflow::XPluginFlowMessage;
using horizon::vision::xpluginflow::XPluginFlowMessagePtr;

using std::chrono::milliseconds;

#define TYPE_SAMPLE_MESSAGE "XPLUGIN_SAMPLE_MESSAGE"
XPLUGIN_REGISTER_MSG_TYPE(XPLUGIN_SAMPLE_MESSAGE)

struct NumberProdMessage : XPluginFlowMessage {
  float num_;
  explicit NumberProdMessage(float num) :num_(num) {
    type_ = TYPE_SAMPLE_MESSAGE;
  }
  std::string Serialize() override {
    std::ostringstream ss;
    ss << num_;
    return std::string(ss.str());
  }
};

class NumberProducerPlugin : public XPluginAsync {
 public:
  NumberProducerPlugin() {
    total_cnt_ = 1000000;
  }
  ~NumberProducerPlugin() = default;

  std::string desc() const {
    return "NumberProducerPlugin";
  }
  int Start() {
    LOGI << "total_cnt=" << total_cnt_;
    prd_thread_ = new std::thread([&] (){
      for (int i = 0; i < total_cnt_ && !prd_stop_; i++) {
        auto np_msg = std::make_shared<NumberProdMessage>(5);
        PushMsg(np_msg);
        std::this_thread::sleep_for(milliseconds(40));
      }
      LOGI << desc() << " prd exit";
    });
  }
  int Stop() {
    prd_stop_ = true;
    prd_thread_->join();
  }

 private:
  uint32_t total_cnt_;
  std::thread *prd_thread_;
  bool prd_stop_{false};
};

class SumConsumerPlugin : public XPluginAsync {
 public:
  SumConsumerPlugin() : sum_(0.0f) {}
  ~SumConsumerPlugin() = default;
  int Init() override {
    sum_ = 0.f;
    RegisterMsg(TYPE_SAMPLE_MESSAGE, std::bind(&SumConsumerPlugin::Sum,
                                               this, std::placeholders::_1));
    return XPluginAsync::Init();
  }
  int Sum(XPluginFlowMessagePtr msg) {
    auto np_msg = std::static_pointer_cast<NumberProdMessage>(msg);
    sum_ += np_msg->num_;
    LOGI << "curr sum:" << sum_;
    return sum_;
  }

  int Stop() {
    return 0;
  }
  std::string desc() const {
    return "SumConsumerPlugin";
  }

 private:
  float sum_;
};

struct SmartContext {
  std::vector<std::shared_ptr<XPluginAsync> > plugins;
  bool exit;
  SmartContext() : exit(false) {
    plugins.clear();
  }
};

SmartContext g_ctx;

static void signal_handle(int param) {
  std::cout << "recv signal " << param
            << ", stop" << std::endl;
  if (param == SIGINT) {
    g_ctx.exit = true;
  }
}

int main() {
  SetLogLevel(HOBOT_LOG_DEBUG);

  signal(SIGINT, signal_handle);
  signal(SIGPIPE, signal_handle);
  signal(SIGSEGV, signal_handle);

  auto np_plg = std::make_shared<NumberProducerPlugin>();
  auto sc_plg = std::make_shared<SumConsumerPlugin>();

  np_plg->Init();
  sc_plg->Init();
  g_ctx.plugins.push_back(np_plg);
  g_ctx.plugins.push_back(sc_plg);

  for (auto& plugin : g_ctx.plugins) {
    plugin->Start();
  }

  while (!g_ctx.exit) {
    milliseconds(40);
  }

  for (auto& plugin : g_ctx.plugins) {
    plugin->Stop();
  }

  return 0;
}
